<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
<<<<<<< HEAD
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My LeetCode Challenge Journaling</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            padding: 20px;
            background-color: #f4f4f4;
            text-align: center;
        }
        h1, h3 {
            color: #333;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
            text-align: left;
        }
        .blog-post {
            border-bottom: 1px solid #ddd;
            padding: 20px 0;
        }

        .blog-post h2 {
            margin-bottom: 5px;
        }
        .blog-post {
            text-align: left;  
}
        .blog-post p {
            color: #666;
        }
        .blog-post .date {
            font-size: 12px;
            color: #888;
        }
        .blog-post a {
            text-decoration: none;
            color: #007bff;
        }
        .profile {
            margin-top: 20px;
            font-size: 18px;
        }
        .profile a {
            color: #007bff;
            text-decoration: none;
            font-weight: bold;
        }
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>

    <h1>Welcome to my pageÔºÅüöÄ</h1>
    <p>I'm starting a daily LeetCode challenge here and documenting my solutions, thoughts, and takeaways.</p>

    <div class="container">
        <h2>Day 1: Mastering Two-Pointer and Binary Search</h2>
        <p class="date">2025-02-11</p>
        
        <p>Today, I started my LeetCode journey with two fundamental problems: <b>Binary Search (704)</b> and <b>Remove Element (27)</b>. 
        These two problems reinforced two key techniques‚Äî<b>Binary Search for efficient searching</b> and <b>Two Pointers for in-place modifications</b>.</p>

        <h3>üìå Problem 1: 704. Binary Search</h3>
        <p>Binary Search is one of the most fundamental techniques when dealing with sorted arrays. Instead of linearly scanning each element, we <b>divide the array in half</b> at each step, reducing the search time from O(n) to <b>O(log n)</b>.</p>

        <pre><code class="language-python">
from typing import List

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if not nums:
            return -1
        if len(nums) == 1 and target in nums:
            return 0 
        l, r = 0, len(nums) - 1
        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                return m
            if nums[m] > target:
                r = m - 1
            else:
                l = m + 1
        return -1
        </code></pre>

        <p>‚úÖ <b>What's up:</b></p>
        <ul>
            <li>Use <b>Binary Search</b> to optimize search time complexity from O(n) to <b>O(log n)</b>.</li>
            <li>If <code>nums[m] > target</code>, search in <b>left half</b> (<code>[l, m-1]</code>).</li>
            <li>If <code>nums[m] < target</code>, search in <b>right half</b> (<code>[m+1, r]</code>).</li>
            <li>The point is always to <b>know your boundaries(l,r) and when to stop</b> (<code>l > r</code>). üòä</li>
        </ul>

        <a href="https://leetcode.cn/problems/binary-search/description/" target="_blank">Try the problem yourself...</a>

        <h3>üìå Problem 2: 27. Remove Element</h3>
        <p>At first, I used a simple brute-force traversal method to solve this problem. But after a second thought, I realized the beauty of the <b>two-pointer technique</b>!</p>

        <pre><code class="language-python">
from typing import List

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        l, r, k = 0, 0, 0
        while r < len(nums):
            if nums[r] != val:
                nums[l] = nums[r]
                k += 1
                l += 1
            r += 1
        return k
        </code></pre>

        <p>‚úÖ <b>Key Learnings:</b></p>
        <ul>
            <li>Instead of creating a new list, we <b>modify the array in place</b> using <b>two pointers (<code>l</code> and <code>r</code>)</b>.</li>
            <li>Pointer <code>r</code> scans the entire list, while <code>l</code> tracks valid elements.</li>
            <li>Less complexity? Not really. <b>More elegance? Absolutely.</b> üíÖ</li>
            <li>Fun fact: <b>I got a 100% performance score on this!</b> üéØ</li>
        </ul>

        <a href="https://leetcode.cn/problems/remove-element/" target="_blank">Now try it...</a>

        <h3>üìå Problem 3: 977. Squares of a Sorted Array</h3>
        <p>Ok, showtime for our beloved friend <b>two-pointer technique</b> when it comes to sorting! üòÇ</p>
        <pre><code class="language-python">
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        l, r = 0, len(nums) - 1
        temp = len(nums) - 1
        x, y = nums[l]**2, nums[r]**2
        ans = nums[:]
        while l <= r:
            if x <= y:
                ans[temp] = y
                r -= 1
                y = nums[r]**2
            else:
                ans[temp] = x
                l += 1
                x = nums[l]**2
            temp -= 1
        return ans
        </code></pre>

        <p>‚úÖ <b>Notes:</b></p>
        <ul>
            <li>Big applauds: I didn't snap it with <code>sort()</code> and call it a day.</li>
            <li>How smart is that! Two pointers can go from two ends and end up hugging each other!! üíï</li>
            <li>Girl now you just lowered a O(nlog(n)) to O(n). üíÖ</li>
        </ul>

        <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/" target="_blank">Now try it...</a>
    </div>

    <div class="container">
        <h2>Day 2: Mastering Sliding Windows</h2>
        <p class="date">2025-02-12</p>
        
        <p>Today, let's crack some seemingly more difficult proplems using special techniques. 
        These two problems are very representative of sliding windows and window boundaries.</p>

        <h3>üìå Problem 1: 209. Minimum Size Subarray Sum</h3>
        <p>Trust me, you don't want the pain of brutal force. Simply adding a window variable can change your life.</p>

        <pre><code class="language-python">
class Solution:
def minSubArrayLen(self, target: int, nums: List[int]) -> int:
    s = 0
    min_len = len(nums)+1
    curr_len = 0
    curr = deque()
    for i,c in enumerate(nums):
        s += c
        curr_len+=1
        curr.append(c)
        if s<target:
            continue
        min_len = min(curr_len, min_len)
        while curr and s>=target:
            head = curr.popleft()
            min_len = min(curr_len, min_len)
            curr_len-=1
            s -= head
    
    return min_len if min_len<=len(nums) else 0
        </code></pre>
        
        <p>‚úÖ <b>What's up:</b></p>
        <ul>
            <li>By keeping a window that's always slightly bigger than target, we move through the whole list with a <b>O(n)</b> complexity.</li>
            <li>The while loop may take a worst of O(n), but only when it comes to the ending elements. So we'll take it as O(n) complexity overall.</li>
            <li>If <code>nums[m] < target</code>, search in <b>right half</b> (<code>[m+1, r]</code>).</li>
            <li>The point is always to maintain a good, thin window when you move forward.</li>
        </ul>
        <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank">Now try it...</a>


    <h3>üìå Problem 2: 59. Spiral Matrix II</h3>
    <p>Imagine you're a snake and you go into the deep, deep center of the square... Boom! There you are, a snake with only head and no tail.</p>

    <pre><code class="language-python">
from typing import List

class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        nums = [[0] * n for _ in range(n)]  # Initialize matrix with 0s
        count = 1  # Start filling numbers from 1
        left, right, top, bottom = 0, n - 1, 0, n - 1  # Define boundaries

        while left <= right and top <= bottom:
            # Fill top row (left to right)
            for j in range(left, right + 1):
                nums[top][j] = count
                count += 1
            top += 1  # Move top boundary down

            # Fill right column (top to bottom)
            for i in range(top, bottom + 1):
                nums[i][right] = count
                count += 1
            right -= 1  # Move right boundary left

            # Fill bottom row (right to left)
            if top <= bottom:  # Prevent duplicate row filling
                for j in range(right, left - 1, -1):
                    nums[bottom][j] = count
                    count += 1
                bottom -= 1  # Move bottom boundary up

            # Fill left column (bottom to top)
            if left <= right:  # Prevent duplicate column filling
                for i in range(bottom, top - 1, -1):
                    nums[i][left] = count
                    count += 1
                left += 1  # Move left boundary right

        return nums
    </code></pre>
    
    <p>‚úÖ <b>Tricks:</b></p>
    <ul>
        <li>Using two pairs of two pointers helps keep track of which circle we're at.</li>
        <li>After each row or column, gently move your boundaries one unit inner.</li>
    </ul>
    <a href="https://leetcode.cn/problems/spiral-matrix-ii/description/" target="_blank">Now try it...</a>



day3
    <h3>üìå Problem 1: 203.Remove Linked List Elements</h3>
    <p>To further get to know list structures, it's always a must to learn about linked list.</p>

    <pre><code class="language-python">
def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
if not head:return head
pre = ListNode()
pre.next = head
temp = pre
while head:
    if head.val == val:
        temp.next = head.next
    else:
        temp = head
    head = head.next
return pre.next
    </code></pre>
    
    <p>‚úÖ <b>Thoughts:</b></p>
    <ul>
        <li>Even I have nailed it hundreds of times, I still got confused what to put down for the first row.</li>
        <li>It's intuitive to initiate a dummy node pre, but when to move the temp and how?</li>
        <li>We always want to move head one unit forward, but when it's equal to val, we would want to move temp's next across to head.next. At the end of the day, temp is what we include in the result.</li>
        <li>Stop, and take a moment to close your eyes to imagine what happened about temp.</li>
    </ul>
    <a href="https://leetcode.cn/problems/remove-linked-list-elements/" target="_blank">Now try it...</a>

    <h3>üìå Problem 2: 707. Design Linked List</h3>
    <p>Design a linked list from scrach!</p>

    <pre><code class="language-python">
class ListNode():
        def __init__(self, val ):
            self.val = val
            self.next = None
class MyLinkedList:
    
        def __init__(self):
            self.size = 0
            self.head = ListNode(0)
    
        def get(self, index: int) -> int:
            if index<0 or index>=self.size:return -1
            temp = self.head
            for _ in range(index+1):
                temp = temp.next
            return temp.val
            
    
        def addAtHead(self, val: int) -> None:
            self.addAtIndex(0, val)
    
        def addAtTail(self, val: int) -> None:
            self.addAtIndex(self.size, val)
    
        def addAtIndex(self, index: int, val: int) -> None:
            if index>self.size : return
            self.size+=1
            pre = self.head
            for _ in range(index):
                pre = pre.next
            new = ListNode(val)
            new.next = pre.next
            pre.next = new
    
        def deleteAtIndex(self, index: int) -> None:
            if index<0 or index>=self.size:
                return
            self.size -= 1
            pre = self.head
            for _ in range(index):
                pre = pre.next
            pre.next = pre.next.next
    </code></pre>
    
    <p>‚úÖ <b>Thoughts:</b></p>
    <ul>
        <li>Looking scary, but there're truly only three functions: addatindex, get, delete.</li>
        <li>It's intuitive to initiate a dummy node pre, but when to move the temp and how?</li>
        <li>Without using a list [], it can be hard to implement. But remember, we have for loops.(always)</li>
        <li>With many for loops and one size variable, you're able to handle it just as lists!</li>
    </ul>


    <h3>üìå Problem 3: 206. Reverse Linked List</h3>
    <p>Think the opposite way!</p>

    <pre><code class="language-python">
class Solution:
def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
    pre = None
    while head:
        temp = head.next
        head.next = pre
        pre = head
        head = temp
    
    return pre
    </code></pre>
    
    <p>‚úÖ <b>My bad:</b></p>
    <ul>
        <li>As it's an easy problem, there can be tricks.</li>
        <li>How do you unconnect the links and rebuild it the other way?</li>
        <li>I made a mistake by using pre as a ListNode(), a dummy variable. But no! Dummy doesn't mean it's a listnode with value 0. It means None! Nothing! Void!</li>
    </ul>
    <a href="https://leetcode.cn/problems/reverse-linked-list/description/" target="_blank">Don't follow my path...</a>


</div>



    



    <div class="profile">
        <p>üì¢ Follow my Bilibili account to get a little bit of my daily life in NYCÔºö</p>
        <a href="https://space.bilibili.com/865132" target="_blank">üëâ ÊàëÁöÑ Bilibili ‰∏ªÈ°µ</a>
    </div>

</body>
</html>

=======
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My LeetCode Challenge Journaling</title>
    <link rel="stylesheet" href="main-style.css">  <!-- ‚úÖ Only for the main page -->
</head>
<body>

    <div class="hero">
        <h1>üöÄ Welcome to Flora's LeetCode Journey</h1>
        <p>Tracking my daily coding challenges, thoughts, and solutions.</p>
    </div>

    <div class="container">
        <h2>üìÖ Challenge Archive</h2>
        <ul class="challenge-list">
            <li><a href="day1.html">Day 1: Two-Pointer & Binary Search</a></li>
            <li><a href="day2.html">Day 2: Sliding Windows</a></li>
            <li><a href="day3.html">Day 3: Linked Lists</a></li>
            <li><a href="day4.html">Day 4: Linked List Advanced</a></li>
            <li><a href="day5.html">Day 5: Hashmap</a></li>
        </ul>
    </div>

    <footer>
        <p>üì¢ Follow my journey on Bilibili: <a href="https://space.bilibili.com/865132" target="_blank">üëâ ÊàëÁöÑ Bilibili ‰∏ªÈ°µ</a></p>
    </footer>

</body>
</html>
>>>>>>> 12edaae (add subpages)
